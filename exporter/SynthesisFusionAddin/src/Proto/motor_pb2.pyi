"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import google.protobuf.descriptor
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import types_pb2
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _DutyCycles:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _DutyCyclesEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_DutyCycles.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    CONTINUOUS_RUNNING: _DutyCycles.ValueType  # 0
    """/ S1"""
    SHORT_TIME: _DutyCycles.ValueType  # 1
    """/ S2"""
    INTERMITTENT_PERIODIC: _DutyCycles.ValueType  # 2
    """/ S3"""
    CONTINUOUS_PERIODIC: _DutyCycles.ValueType  # 3
    """/ S6 Continuous Operation with Periodic Duty"""

class DutyCycles(_DutyCycles, metaclass=_DutyCyclesEnumTypeWrapper):
    """*
    Duty Cycles for electric motors
    Affects the dynamic output of the motor
    https://www.news.benevelli-group.com/index.php/en/88-what-motor-duty-cycle.html
    These each have associated data we are not going to use right now
    """

CONTINUOUS_RUNNING: DutyCycles.ValueType  # 0
"""/ S1"""
SHORT_TIME: DutyCycles.ValueType  # 1
"""/ S2"""
INTERMITTENT_PERIODIC: DutyCycles.ValueType  # 2
"""/ S3"""
CONTINUOUS_PERIODIC: DutyCycles.ValueType  # 3
"""/ S6 Continuous Operation with Periodic Duty"""
global___DutyCycles = DutyCycles

@typing.final
class Motor(google.protobuf.message.Message):
    """*
    A Motor should determine the relationship between an input and joint motion
    Could represent something like a DC Motor relationship
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    INFO_FIELD_NUMBER: builtins.int
    DC_MOTOR_FIELD_NUMBER: builtins.int
    SIMPLE_MOTOR_FIELD_NUMBER: builtins.int
    @property
    def info(self) -> types_pb2.Info: ...
    @property
    def dc_motor(self) -> global___DCMotor: ...
    @property
    def simple_motor(self) -> global___SimpleMotor: ...
    def __init__(
        self,
        *,
        info: types_pb2.Info | None = ...,
        dc_motor: global___DCMotor | None = ...,
        simple_motor: global___SimpleMotor | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["dc_motor", b"dc_motor", "info", b"info", "motor_type", b"motor_type", "simple_motor", b"simple_motor"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["dc_motor", b"dc_motor", "info", b"info", "motor_type", b"motor_type", "simple_motor", b"simple_motor"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["motor_type", b"motor_type"]) -> typing.Literal["dc_motor", "simple_motor"] | None: ...

global___Motor = Motor

@typing.final
class SimpleMotor(google.protobuf.message.Message):
    """*
    SimpleMotor Configuration
    Very easy motor used to simulate joints without specifying a real motor
    Can set braking_constant - stall_torque - and max_velocity
    Assumes you are solving using a velocity constraint for a joint and not a acceleration constraint
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    STALL_TORQUE_FIELD_NUMBER: builtins.int
    MAX_VELOCITY_FIELD_NUMBER: builtins.int
    BRAKING_CONSTANT_FIELD_NUMBER: builtins.int
    stall_torque: builtins.float
    """/ Torque at 0 rpm with a inverse linear relationship to max_velocity"""
    max_velocity: builtins.float
    """/ The target velocity in RPM, will use stall_torque relationship to reach each step"""
    braking_constant: builtins.float
    """/ (Optional) 0 - 1, the relationship of stall_torque used to perserve the position of this motor"""
    def __init__(
        self,
        *,
        stall_torque: builtins.float = ...,
        max_velocity: builtins.float = ...,
        braking_constant: builtins.float = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["braking_constant", b"braking_constant", "max_velocity", b"max_velocity", "stall_torque", b"stall_torque"]) -> None: ...

global___SimpleMotor = SimpleMotor

@typing.final
class DCMotor(google.protobuf.message.Message):
    """*
    DCMotor Configuration
    Parameters to simulate a DC Electric Motor
    Still needs some more but overall they are most of the parameters we can use
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class Advanced(google.protobuf.message.Message):
        """/ Information usually found on datasheet"""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        FREE_CURRENT_FIELD_NUMBER: builtins.int
        FREE_SPEED_FIELD_NUMBER: builtins.int
        STALL_CURRENT_FIELD_NUMBER: builtins.int
        STALL_TORQUE_FIELD_NUMBER: builtins.int
        INPUT_VOLTAGE_FIELD_NUMBER: builtins.int
        RESISTANCE_VARIATION_FIELD_NUMBER: builtins.int
        free_current: builtins.float
        """/ measured in AMPs"""
        free_speed: builtins.int
        """/ measured in RPM"""
        stall_current: builtins.float
        """/ measure in AMPs"""
        stall_torque: builtins.float
        """/ measured in Nm"""
        input_voltage: builtins.int
        """/ measured in Volts DC"""
        resistance_variation: builtins.float
        """/ between (K * (N / 4)) and (K * ((N-2) / 4)) where N is number of poles - leave at 0 if unknown"""
        def __init__(
            self,
            *,
            free_current: builtins.float = ...,
            free_speed: builtins.int = ...,
            stall_current: builtins.float = ...,
            stall_torque: builtins.float = ...,
            input_voltage: builtins.int = ...,
            resistance_variation: builtins.float = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["free_current", b"free_current", "free_speed", b"free_speed", "input_voltage", b"input_voltage", "resistance_variation", b"resistance_variation", "stall_current", b"stall_current", "stall_torque", b"stall_torque"]) -> None: ...

    REFERENCE_URL_FIELD_NUMBER: builtins.int
    TORQUE_CONSTANT_FIELD_NUMBER: builtins.int
    EMF_CONSTANT_FIELD_NUMBER: builtins.int
    RESISTANCE_FIELD_NUMBER: builtins.int
    MAXIMUM_EFFECIENCY_FIELD_NUMBER: builtins.int
    MAXIMUM_POWER_FIELD_NUMBER: builtins.int
    DUTY_CYCLE_FIELD_NUMBER: builtins.int
    ADVANCED_FIELD_NUMBER: builtins.int
    reference_url: builtins.str
    """/ Reference for purchase page or spec sheet"""
    torque_constant: builtins.float
    """/ m-Nm/Amp"""
    emf_constant: builtins.float
    """/ mV/rad/sec"""
    resistance: builtins.float
    """/ Resistance of Motor - Optional if other values are known"""
    maximum_effeciency: builtins.int
    """/ measure in percentage of 100 - generally around 60 - measured under optimal load"""
    maximum_power: builtins.int
    """/ measured in Watts"""
    duty_cycle: global___DutyCycles.ValueType
    """/ Stated Duty Cycle of motor"""
    @property
    def advanced(self) -> global___DCMotor.Advanced:
        """/ Optional data that can give a better relationship to the simulation"""

    def __init__(
        self,
        *,
        reference_url: builtins.str = ...,
        torque_constant: builtins.float = ...,
        emf_constant: builtins.float = ...,
        resistance: builtins.float = ...,
        maximum_effeciency: builtins.int = ...,
        maximum_power: builtins.int = ...,
        duty_cycle: global___DutyCycles.ValueType = ...,
        advanced: global___DCMotor.Advanced | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["advanced", b"advanced"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["advanced", b"advanced", "duty_cycle", b"duty_cycle", "emf_constant", b"emf_constant", "maximum_effeciency", b"maximum_effeciency", "maximum_power", b"maximum_power", "reference_url", b"reference_url", "resistance", b"resistance", "torque_constant", b"torque_constant"]) -> None: ...

global___DCMotor = DCMotor
