syntax = "proto3";

message MessageHeader {
	bool is_encrypted = 1;
	string client_id = 2; // only necessary for UDP hole-punching
}

// Pack messages as the 'Any' type before sending

message StatusMessage {
	LogLevel log_level = 1;
	string msg = 2;

	enum LogLevel {
		INFO = 0;
		WARNING = 1;
		ERROR = 2;
	}
}

message GenericResponse {
	bool success = 1;
	string log_message = 2;
}

// Sent by both clients and server to establish shared secrets and client_ids
message KeyExchange {
	string p = 1;
	string g = 2; 
	string public_key = 3;
	string client_id = 4; /// Determined by server and sent back. Whatever the client sends is ignored
}

message LobbyInfo {
	repeated Lobby lobbies = 1;
	string current_lobby = 2;
		
	message Lobby {
		string lobby_name = 1;
		map<string, string> clients = 2;
	}
}

message Heartbeat {
	string client_id = 1;
}


message CreateLobbyRequest {
	string client_id = 1;
	string lobby_name = 2;
}

message CreateLobbyResponse {
	string client_id = 1;
	string lobby_name = 2;
	GenericResponse generic_response = 3;
}


message DeleteLobbyRequest {
	string client_id = 1;
	string lobby_name = 2;
}

message DeleteLobbyResponse {
	string client_id = 1;
	string lobby_name = 2;
	GenericResponse generic_response = 3;
}


message JoinLobbyRequest {
	string client_id = 1;
	string lobby_name = 2;
}

message JoinLobbyResponse {
	string client_id = 1;
	string lobby_name = 2;
	GenericResponse generic_response = 3;
}


message LeaveLobbyRequest {
	string client_id = 1;
	string lobby_name = 2;
}

message LeaveLobbyResponse {
	string client_id = 1;
	string lobby_name = 2;
	GenericResponse generic_response = 3;
}


message StartLobbyRequest {
	string client_id = 1;
	string lobby_name = 2;
}

message StartLobbyResponse {
	string client_id = 1;
	string lobby_name = 2;
	GenericResponse generic_response = 3;
}


message SwapRequest {
	string client_id = 1;
	string lobby_name = 2;

	int32 first_postion = 3;
	int32 second_postion = 4;
}

message SwapResponse {
	string client_id = 1;
	string lobby_name = 2;

	int32 first_postion = 3;
	int32 second_postion = 4;
	GenericResponse generic_response = 5;
}

/*
1. When lobby is started the server will send a MatchStart message over TCP with the open UDP port number
2. Clients in that lobby will then begin broadcasting the MatchStartResponse to the server on the specified UDP port
3. Upon recieving the match response the server will record the IPEndPoint of the UDP Connection
4. After receiving a response from each client the server will send a connection data message over UDP
*/

message MatchStart {
	int32 udp_port = 1;
}

// sent by the client over udp
message MatchStartResponse {}

message ConnectionDataHost {
	repeated string client_enpoints = 1; // includes the host as the index corresponds with lobby position
}

message ConnectionDataClient {
	string host_endpoint = 1;
}






